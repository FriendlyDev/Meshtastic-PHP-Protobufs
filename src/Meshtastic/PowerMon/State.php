<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: meshtastic/powermon.proto

namespace Meshtastic\PowerMon;

use UnexpectedValueException;

/**
 * Any significant power changing event in meshtastic should be tagged with a powermon state transition.
 *If you are making new meshtastic features feel free to add new entries at the end of this definition.
 *
 * Protobuf type <code>meshtastic.PowerMon.State</code>
 */
class State
{
    /**
     * Generated from protobuf enum <code>None = 0;</code>
     */
    const None = 0;
    /**
     * Generated from protobuf enum <code>CPU_DeepSleep = 1;</code>
     */
    const CPU_DeepSleep = 1;
    /**
     * Generated from protobuf enum <code>CPU_LightSleep = 2;</code>
     */
    const CPU_LightSleep = 2;
    /**
     *The external Vext1 power is on.  Many boards have auxillary power rails that the CPU turns on only
     *occasionally.  In cases where that rail has multiple devices on it we usually want to have logging on
     *the state of that rail as an independent record.
     *For instance on the Heltec Tracker 1.1 board, this rail is the power source for the GPS and screen.
     *The log messages will be short and complete (see PowerMon.Event in the protobufs for details).
     *something like "S:PM:C,0x00001234,REASON" where the hex number is the bitmask of all current states.
     *(We use a bitmask for states so that if a log message gets lost it won't be fatal)
     *
     * Generated from protobuf enum <code>Vext1_On = 4;</code>
     */
    const Vext1_On = 4;
    /**
     * Generated from protobuf enum <code>Lora_RXOn = 8;</code>
     */
    const Lora_RXOn = 8;
    /**
     * Generated from protobuf enum <code>Lora_TXOn = 16;</code>
     */
    const Lora_TXOn = 16;
    /**
     * Generated from protobuf enum <code>Lora_RXActive = 32;</code>
     */
    const Lora_RXActive = 32;
    /**
     * Generated from protobuf enum <code>BT_On = 64;</code>
     */
    const BT_On = 64;
    /**
     * Generated from protobuf enum <code>LED_On = 128;</code>
     */
    const LED_On = 128;
    /**
     * Generated from protobuf enum <code>Screen_On = 256;</code>
     */
    const Screen_On = 256;
    /**
     * Generated from protobuf enum <code>Screen_Drawing = 512;</code>
     */
    const Screen_Drawing = 512;
    /**
     * Generated from protobuf enum <code>Wifi_On = 1024;</code>
     */
    const Wifi_On = 1024;
    /**
     *GPS is actively trying to find our location
     *See GPSPowerState for more details
     *
     * Generated from protobuf enum <code>GPS_Active = 2048;</code>
     */
    const GPS_Active = 2048;

    private static $valueToName = [
        self::None => 'None',
        self::CPU_DeepSleep => 'CPU_DeepSleep',
        self::CPU_LightSleep => 'CPU_LightSleep',
        self::Vext1_On => 'Vext1_On',
        self::Lora_RXOn => 'Lora_RXOn',
        self::Lora_TXOn => 'Lora_TXOn',
        self::Lora_RXActive => 'Lora_RXActive',
        self::BT_On => 'BT_On',
        self::LED_On => 'LED_On',
        self::Screen_On => 'Screen_On',
        self::Screen_Drawing => 'Screen_Drawing',
        self::Wifi_On => 'Wifi_On',
        self::GPS_Active => 'GPS_Active',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(State::class, \Meshtastic\PowerMon_State::class);

