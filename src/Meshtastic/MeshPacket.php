<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: meshtastic/mesh.proto

namespace Meshtastic;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * A packet envelope sent/received over the mesh
 * only payload_variant is sent in the payload portion of the LORA packet.
 * The other fields are either not sent at all, or sent in the special 16 byte LORA header.
 *
 * Generated from protobuf message <code>meshtastic.MeshPacket</code>
 */
class MeshPacket extends \Google\Protobuf\Internal\Message
{
    /**
     * The sending node number.
     * Note: Our crypto implementation uses this field as well.
     * See [crypto](/docs/overview/encryption) for details.
     *
     * Generated from protobuf field <code>fixed32 from = 1;</code>
     */
    protected $from = 0;
    /**
     * The (immediate) destination for this packet
     *
     * Generated from protobuf field <code>fixed32 to = 2;</code>
     */
    protected $to = 0;
    /**
     * (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
     * If unset, packet was on the primary channel.
     * A particular node might know only a subset of channels in use on the mesh.
     * Therefore channel_index is inherently a local concept and meaningless to send between nodes.
     * Very briefly, while sending and receiving deep inside the device Router code, this field instead
     * contains the 'channel hash' instead of the index.
     * This 'trick' is only used while the payload_variant is an 'encrypted'.
     *
     * Generated from protobuf field <code>uint32 channel = 3;</code>
     */
    protected $channel = 0;
    /**
     * A unique ID for this packet.
     * Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
     * Otherwise a unique ID for this packet, useful for flooding algorithms.
     * ID only needs to be unique on a _per sender_ basis, and it only
     * needs to be unique for a few minutes (long enough to last for the length of
     * any ACK or the completion of a mesh broadcast flood).
     * Note: Our crypto implementation uses this id as well.
     * See [crypto](/docs/overview/encryption) for details.
     *
     * Generated from protobuf field <code>fixed32 id = 6;</code>
     */
    protected $id = 0;
    /**
     * The time this message was received by the esp32 (secs since 1970).
     * Note: this field is _never_ sent on the radio link itself (to save space) Times
     * are typically not sent over the mesh, but they will be added to any Packet
     * (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
     *
     * Generated from protobuf field <code>fixed32 rx_time = 7;</code>
     */
    protected $rx_time = 0;
    /**
     * *Never* sent over the radio links.
     * Set during reception to indicate the SNR of this packet.
     * Used to collect statistics on current link quality.
     *
     * Generated from protobuf field <code>float rx_snr = 8;</code>
     */
    protected $rx_snr = 0.0;
    /**
     * If unset treated as zero (no forwarding, send to direct neighbor nodes only)
     * if 1, allow hopping through one node, etc...
     * For our usecase real world topologies probably have a max of about 3.
     * This field is normally placed into a few of bits in the header.
     *
     * Generated from protobuf field <code>uint32 hop_limit = 9;</code>
     */
    protected $hop_limit = 0;
    /**
     * This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
     * We would like to receive a ack packet in response.
     * Broadcasts messages treat this flag specially: Since acks for broadcasts would
     * rapidly flood the channel, the normal ack behavior is suppressed.
     * Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
     * If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
     * So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
     * If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
     * Note: This flag is normally sent in a flag bit in the header when sent over the wire
     *
     * Generated from protobuf field <code>bool want_ack = 10;</code>
     */
    protected $want_ack = false;
    /**
     * The priority of this message for sending.
     * See MeshPacket.Priority description for more details.
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.Priority priority = 11;</code>
     */
    protected $priority = 0;
    /**
     * rssi of received packet. Only sent to phone for dispay purposes.
     *
     * Generated from protobuf field <code>int32 rx_rssi = 12;</code>
     */
    protected $rx_rssi = 0;
    /**
     * Describe if this message is delayed
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];</code>
     * @deprecated
     */
    protected $delayed = 0;
    /**
     * Describes whether this packet passed via MQTT somewhere along the path it currently took.
     *
     * Generated from protobuf field <code>bool via_mqtt = 14;</code>
     */
    protected $via_mqtt = false;
    /**
     * Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
     * When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
     *
     * Generated from protobuf field <code>uint32 hop_start = 15;</code>
     */
    protected $hop_start = 0;
    /**
     * Records the public key the packet was encrypted with, if applicable.
     *
     * Generated from protobuf field <code>bytes public_key = 16;</code>
     */
    protected $public_key = '';
    /**
     * Indicates whether the packet was en/decrypted using PKI
     *
     * Generated from protobuf field <code>bool pki_encrypted = 17;</code>
     */
    protected $pki_encrypted = false;
    /**
     * Last byte of the node number of the node that should be used as the next hop in routing.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 next_hop = 18;</code>
     */
    protected $next_hop = 0;
    /**
     * Last byte of the node number of the node that will relay/relayed this packet.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 relay_node = 19;</code>
     */
    protected $relay_node = 0;
    /**
     * *Never* sent over the radio links.
     * Timestamp after which this packet may be sent.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 tx_after = 20;</code>
     */
    protected $tx_after = 0;
    /**
     * Indicates which transport mechanism this packet arrived over
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;</code>
     */
    protected $transport_mechanism = 0;
    protected $payload_variant;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int $from
     *           The sending node number.
     *           Note: Our crypto implementation uses this field as well.
     *           See [crypto](/docs/overview/encryption) for details.
     *     @type int $to
     *           The (immediate) destination for this packet
     *     @type int $channel
     *           (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
     *           If unset, packet was on the primary channel.
     *           A particular node might know only a subset of channels in use on the mesh.
     *           Therefore channel_index is inherently a local concept and meaningless to send between nodes.
     *           Very briefly, while sending and receiving deep inside the device Router code, this field instead
     *           contains the 'channel hash' instead of the index.
     *           This 'trick' is only used while the payload_variant is an 'encrypted'.
     *     @type \Meshtastic\Data $decoded
     *           TODO: REPLACE
     *     @type string $encrypted
     *           TODO: REPLACE
     *     @type int $id
     *           A unique ID for this packet.
     *           Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
     *           Otherwise a unique ID for this packet, useful for flooding algorithms.
     *           ID only needs to be unique on a _per sender_ basis, and it only
     *           needs to be unique for a few minutes (long enough to last for the length of
     *           any ACK or the completion of a mesh broadcast flood).
     *           Note: Our crypto implementation uses this id as well.
     *           See [crypto](/docs/overview/encryption) for details.
     *     @type int $rx_time
     *           The time this message was received by the esp32 (secs since 1970).
     *           Note: this field is _never_ sent on the radio link itself (to save space) Times
     *           are typically not sent over the mesh, but they will be added to any Packet
     *           (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
     *     @type float $rx_snr
     *           *Never* sent over the radio links.
     *           Set during reception to indicate the SNR of this packet.
     *           Used to collect statistics on current link quality.
     *     @type int $hop_limit
     *           If unset treated as zero (no forwarding, send to direct neighbor nodes only)
     *           if 1, allow hopping through one node, etc...
     *           For our usecase real world topologies probably have a max of about 3.
     *           This field is normally placed into a few of bits in the header.
     *     @type bool $want_ack
     *           This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
     *           We would like to receive a ack packet in response.
     *           Broadcasts messages treat this flag specially: Since acks for broadcasts would
     *           rapidly flood the channel, the normal ack behavior is suppressed.
     *           Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
     *           If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
     *           So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
     *           If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
     *           Note: This flag is normally sent in a flag bit in the header when sent over the wire
     *     @type int $priority
     *           The priority of this message for sending.
     *           See MeshPacket.Priority description for more details.
     *     @type int $rx_rssi
     *           rssi of received packet. Only sent to phone for dispay purposes.
     *     @type int $delayed
     *           Describe if this message is delayed
     *     @type bool $via_mqtt
     *           Describes whether this packet passed via MQTT somewhere along the path it currently took.
     *     @type int $hop_start
     *           Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
     *           When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
     *     @type string $public_key
     *           Records the public key the packet was encrypted with, if applicable.
     *     @type bool $pki_encrypted
     *           Indicates whether the packet was en/decrypted using PKI
     *     @type int $next_hop
     *           Last byte of the node number of the node that should be used as the next hop in routing.
     *           Set by the firmware internally, clients are not supposed to set this.
     *     @type int $relay_node
     *           Last byte of the node number of the node that will relay/relayed this packet.
     *           Set by the firmware internally, clients are not supposed to set this.
     *     @type int $tx_after
     *           *Never* sent over the radio links.
     *           Timestamp after which this packet may be sent.
     *           Set by the firmware internally, clients are not supposed to set this.
     *     @type int $transport_mechanism
     *           Indicates which transport mechanism this packet arrived over
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Meshtastic\Mesh::initOnce();
        parent::__construct($data);
    }

    /**
     * The sending node number.
     * Note: Our crypto implementation uses this field as well.
     * See [crypto](/docs/overview/encryption) for details.
     *
     * Generated from protobuf field <code>fixed32 from = 1;</code>
     * @return int
     */
    public function getFrom()
    {
        return $this->from;
    }

    /**
     * The sending node number.
     * Note: Our crypto implementation uses this field as well.
     * See [crypto](/docs/overview/encryption) for details.
     *
     * Generated from protobuf field <code>fixed32 from = 1;</code>
     * @param int $var
     * @return $this
     */
    public function setFrom($var)
    {
        GPBUtil::checkUint32($var);
        $this->from = $var;

        return $this;
    }

    /**
     * The (immediate) destination for this packet
     *
     * Generated from protobuf field <code>fixed32 to = 2;</code>
     * @return int
     */
    public function getTo()
    {
        return $this->to;
    }

    /**
     * The (immediate) destination for this packet
     *
     * Generated from protobuf field <code>fixed32 to = 2;</code>
     * @param int $var
     * @return $this
     */
    public function setTo($var)
    {
        GPBUtil::checkUint32($var);
        $this->to = $var;

        return $this;
    }

    /**
     * (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
     * If unset, packet was on the primary channel.
     * A particular node might know only a subset of channels in use on the mesh.
     * Therefore channel_index is inherently a local concept and meaningless to send between nodes.
     * Very briefly, while sending and receiving deep inside the device Router code, this field instead
     * contains the 'channel hash' instead of the index.
     * This 'trick' is only used while the payload_variant is an 'encrypted'.
     *
     * Generated from protobuf field <code>uint32 channel = 3;</code>
     * @return int
     */
    public function getChannel()
    {
        return $this->channel;
    }

    /**
     * (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
     * If unset, packet was on the primary channel.
     * A particular node might know only a subset of channels in use on the mesh.
     * Therefore channel_index is inherently a local concept and meaningless to send between nodes.
     * Very briefly, while sending and receiving deep inside the device Router code, this field instead
     * contains the 'channel hash' instead of the index.
     * This 'trick' is only used while the payload_variant is an 'encrypted'.
     *
     * Generated from protobuf field <code>uint32 channel = 3;</code>
     * @param int $var
     * @return $this
     */
    public function setChannel($var)
    {
        GPBUtil::checkUint32($var);
        $this->channel = $var;

        return $this;
    }

    /**
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.meshtastic.Data decoded = 4;</code>
     * @return \Meshtastic\Data|null
     */
    public function getDecoded()
    {
        return $this->readOneof(4);
    }

    public function hasDecoded()
    {
        return $this->hasOneof(4);
    }

    /**
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.meshtastic.Data decoded = 4;</code>
     * @param \Meshtastic\Data $var
     * @return $this
     */
    public function setDecoded($var)
    {
        GPBUtil::checkMessage($var, \Meshtastic\Data::class);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>bytes encrypted = 5;</code>
     * @return string
     */
    public function getEncrypted()
    {
        return $this->readOneof(5);
    }

    public function hasEncrypted()
    {
        return $this->hasOneof(5);
    }

    /**
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>bytes encrypted = 5;</code>
     * @param string $var
     * @return $this
     */
    public function setEncrypted($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(5, $var);

        return $this;
    }

    /**
     * A unique ID for this packet.
     * Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
     * Otherwise a unique ID for this packet, useful for flooding algorithms.
     * ID only needs to be unique on a _per sender_ basis, and it only
     * needs to be unique for a few minutes (long enough to last for the length of
     * any ACK or the completion of a mesh broadcast flood).
     * Note: Our crypto implementation uses this id as well.
     * See [crypto](/docs/overview/encryption) for details.
     *
     * Generated from protobuf field <code>fixed32 id = 6;</code>
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * A unique ID for this packet.
     * Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
     * Otherwise a unique ID for this packet, useful for flooding algorithms.
     * ID only needs to be unique on a _per sender_ basis, and it only
     * needs to be unique for a few minutes (long enough to last for the length of
     * any ACK or the completion of a mesh broadcast flood).
     * Note: Our crypto implementation uses this id as well.
     * See [crypto](/docs/overview/encryption) for details.
     *
     * Generated from protobuf field <code>fixed32 id = 6;</code>
     * @param int $var
     * @return $this
     */
    public function setId($var)
    {
        GPBUtil::checkUint32($var);
        $this->id = $var;

        return $this;
    }

    /**
     * The time this message was received by the esp32 (secs since 1970).
     * Note: this field is _never_ sent on the radio link itself (to save space) Times
     * are typically not sent over the mesh, but they will be added to any Packet
     * (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
     *
     * Generated from protobuf field <code>fixed32 rx_time = 7;</code>
     * @return int
     */
    public function getRxTime()
    {
        return $this->rx_time;
    }

    /**
     * The time this message was received by the esp32 (secs since 1970).
     * Note: this field is _never_ sent on the radio link itself (to save space) Times
     * are typically not sent over the mesh, but they will be added to any Packet
     * (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
     *
     * Generated from protobuf field <code>fixed32 rx_time = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setRxTime($var)
    {
        GPBUtil::checkUint32($var);
        $this->rx_time = $var;

        return $this;
    }

    /**
     * *Never* sent over the radio links.
     * Set during reception to indicate the SNR of this packet.
     * Used to collect statistics on current link quality.
     *
     * Generated from protobuf field <code>float rx_snr = 8;</code>
     * @return float
     */
    public function getRxSnr()
    {
        return $this->rx_snr;
    }

    /**
     * *Never* sent over the radio links.
     * Set during reception to indicate the SNR of this packet.
     * Used to collect statistics on current link quality.
     *
     * Generated from protobuf field <code>float rx_snr = 8;</code>
     * @param float $var
     * @return $this
     */
    public function setRxSnr($var)
    {
        GPBUtil::checkFloat($var);
        $this->rx_snr = $var;

        return $this;
    }

    /**
     * If unset treated as zero (no forwarding, send to direct neighbor nodes only)
     * if 1, allow hopping through one node, etc...
     * For our usecase real world topologies probably have a max of about 3.
     * This field is normally placed into a few of bits in the header.
     *
     * Generated from protobuf field <code>uint32 hop_limit = 9;</code>
     * @return int
     */
    public function getHopLimit()
    {
        return $this->hop_limit;
    }

    /**
     * If unset treated as zero (no forwarding, send to direct neighbor nodes only)
     * if 1, allow hopping through one node, etc...
     * For our usecase real world topologies probably have a max of about 3.
     * This field is normally placed into a few of bits in the header.
     *
     * Generated from protobuf field <code>uint32 hop_limit = 9;</code>
     * @param int $var
     * @return $this
     */
    public function setHopLimit($var)
    {
        GPBUtil::checkUint32($var);
        $this->hop_limit = $var;

        return $this;
    }

    /**
     * This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
     * We would like to receive a ack packet in response.
     * Broadcasts messages treat this flag specially: Since acks for broadcasts would
     * rapidly flood the channel, the normal ack behavior is suppressed.
     * Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
     * If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
     * So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
     * If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
     * Note: This flag is normally sent in a flag bit in the header when sent over the wire
     *
     * Generated from protobuf field <code>bool want_ack = 10;</code>
     * @return bool
     */
    public function getWantAck()
    {
        return $this->want_ack;
    }

    /**
     * This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
     * We would like to receive a ack packet in response.
     * Broadcasts messages treat this flag specially: Since acks for broadcasts would
     * rapidly flood the channel, the normal ack behavior is suppressed.
     * Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
     * If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
     * So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
     * If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
     * Note: This flag is normally sent in a flag bit in the header when sent over the wire
     *
     * Generated from protobuf field <code>bool want_ack = 10;</code>
     * @param bool $var
     * @return $this
     */
    public function setWantAck($var)
    {
        GPBUtil::checkBool($var);
        $this->want_ack = $var;

        return $this;
    }

    /**
     * The priority of this message for sending.
     * See MeshPacket.Priority description for more details.
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.Priority priority = 11;</code>
     * @return int
     */
    public function getPriority()
    {
        return $this->priority;
    }

    /**
     * The priority of this message for sending.
     * See MeshPacket.Priority description for more details.
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.Priority priority = 11;</code>
     * @param int $var
     * @return $this
     */
    public function setPriority($var)
    {
        GPBUtil::checkEnum($var, \Meshtastic\MeshPacket\Priority::class);
        $this->priority = $var;

        return $this;
    }

    /**
     * rssi of received packet. Only sent to phone for dispay purposes.
     *
     * Generated from protobuf field <code>int32 rx_rssi = 12;</code>
     * @return int
     */
    public function getRxRssi()
    {
        return $this->rx_rssi;
    }

    /**
     * rssi of received packet. Only sent to phone for dispay purposes.
     *
     * Generated from protobuf field <code>int32 rx_rssi = 12;</code>
     * @param int $var
     * @return $this
     */
    public function setRxRssi($var)
    {
        GPBUtil::checkInt32($var);
        $this->rx_rssi = $var;

        return $this;
    }

    /**
     * Describe if this message is delayed
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];</code>
     * @return int
     * @deprecated
     */
    public function getDelayed()
    {
        @trigger_error('delayed is deprecated.', E_USER_DEPRECATED);
        return $this->delayed;
    }

    /**
     * Describe if this message is delayed
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];</code>
     * @param int $var
     * @return $this
     * @deprecated
     */
    public function setDelayed($var)
    {
        @trigger_error('delayed is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkEnum($var, \Meshtastic\MeshPacket\Delayed::class);
        $this->delayed = $var;

        return $this;
    }

    /**
     * Describes whether this packet passed via MQTT somewhere along the path it currently took.
     *
     * Generated from protobuf field <code>bool via_mqtt = 14;</code>
     * @return bool
     */
    public function getViaMqtt()
    {
        return $this->via_mqtt;
    }

    /**
     * Describes whether this packet passed via MQTT somewhere along the path it currently took.
     *
     * Generated from protobuf field <code>bool via_mqtt = 14;</code>
     * @param bool $var
     * @return $this
     */
    public function setViaMqtt($var)
    {
        GPBUtil::checkBool($var);
        $this->via_mqtt = $var;

        return $this;
    }

    /**
     * Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
     * When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
     *
     * Generated from protobuf field <code>uint32 hop_start = 15;</code>
     * @return int
     */
    public function getHopStart()
    {
        return $this->hop_start;
    }

    /**
     * Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
     * When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
     *
     * Generated from protobuf field <code>uint32 hop_start = 15;</code>
     * @param int $var
     * @return $this
     */
    public function setHopStart($var)
    {
        GPBUtil::checkUint32($var);
        $this->hop_start = $var;

        return $this;
    }

    /**
     * Records the public key the packet was encrypted with, if applicable.
     *
     * Generated from protobuf field <code>bytes public_key = 16;</code>
     * @return string
     */
    public function getPublicKey()
    {
        return $this->public_key;
    }

    /**
     * Records the public key the packet was encrypted with, if applicable.
     *
     * Generated from protobuf field <code>bytes public_key = 16;</code>
     * @param string $var
     * @return $this
     */
    public function setPublicKey($var)
    {
        GPBUtil::checkString($var, False);
        $this->public_key = $var;

        return $this;
    }

    /**
     * Indicates whether the packet was en/decrypted using PKI
     *
     * Generated from protobuf field <code>bool pki_encrypted = 17;</code>
     * @return bool
     */
    public function getPkiEncrypted()
    {
        return $this->pki_encrypted;
    }

    /**
     * Indicates whether the packet was en/decrypted using PKI
     *
     * Generated from protobuf field <code>bool pki_encrypted = 17;</code>
     * @param bool $var
     * @return $this
     */
    public function setPkiEncrypted($var)
    {
        GPBUtil::checkBool($var);
        $this->pki_encrypted = $var;

        return $this;
    }

    /**
     * Last byte of the node number of the node that should be used as the next hop in routing.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 next_hop = 18;</code>
     * @return int
     */
    public function getNextHop()
    {
        return $this->next_hop;
    }

    /**
     * Last byte of the node number of the node that should be used as the next hop in routing.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 next_hop = 18;</code>
     * @param int $var
     * @return $this
     */
    public function setNextHop($var)
    {
        GPBUtil::checkUint32($var);
        $this->next_hop = $var;

        return $this;
    }

    /**
     * Last byte of the node number of the node that will relay/relayed this packet.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 relay_node = 19;</code>
     * @return int
     */
    public function getRelayNode()
    {
        return $this->relay_node;
    }

    /**
     * Last byte of the node number of the node that will relay/relayed this packet.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 relay_node = 19;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayNode($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_node = $var;

        return $this;
    }

    /**
     * *Never* sent over the radio links.
     * Timestamp after which this packet may be sent.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 tx_after = 20;</code>
     * @return int
     */
    public function getTxAfter()
    {
        return $this->tx_after;
    }

    /**
     * *Never* sent over the radio links.
     * Timestamp after which this packet may be sent.
     * Set by the firmware internally, clients are not supposed to set this.
     *
     * Generated from protobuf field <code>uint32 tx_after = 20;</code>
     * @param int $var
     * @return $this
     */
    public function setTxAfter($var)
    {
        GPBUtil::checkUint32($var);
        $this->tx_after = $var;

        return $this;
    }

    /**
     * Indicates which transport mechanism this packet arrived over
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;</code>
     * @return int
     */
    public function getTransportMechanism()
    {
        return $this->transport_mechanism;
    }

    /**
     * Indicates which transport mechanism this packet arrived over
     *
     * Generated from protobuf field <code>.meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;</code>
     * @param int $var
     * @return $this
     */
    public function setTransportMechanism($var)
    {
        GPBUtil::checkEnum($var, \Meshtastic\MeshPacket\TransportMechanism::class);
        $this->transport_mechanism = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getPayloadVariant()
    {
        return $this->whichOneof("payload_variant");
    }

}

